`HashMap` 类型储存了一个键类型 `K` 对应一个值类型 `V` 的映射。它通过一个 **哈希函数**（*hashing function*）来实现映射，决定如何将键和值放入内存中。

```rust
#![allow(unused_variables)]
fn main() {
    use std::collections::HashMap;
    let mut scores = HashMap::new();
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
}
```

像 vector 一样，哈希 map 将它们的数据储存在堆上，这个 `HashMap` 的键类型是 `String` 而值类型是 `i32`。类似于 vector，哈希 map 是同质的：所有的键必须是相同类型，值也必须都是相同类型。

对于像 `i32` 这样的实现了 `Copy` trait 的类型，其值可以拷贝进哈希 map。对于像 `String` 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者。

```rust
let field_name = String::from("Favorite color");
let mut map = HashMap::new();
map.insert(field_name, "Blue");
//println!("{}",field_name)
```

当 `insert` 调用将 `field_name` 移动到哈希 map 中后，将不能使用这两个绑定。

如果将值的引用插入哈希 map，这些值本身将不会被移动进哈希 map。但是这些引用指向的值必须至少在哈希 map 有效时也是有效的。

可以通过 `get` 方法并提供对应的键来从哈希 map 中获取值

```rust
let  o = map.get(&("Favorite color".to_string()));
println!("{}",o.unwrap());
for (k,v) in map{
  println!("{},{}", k,v)
}
```

插入数据

```rust
let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
let v = scores.entry(String::from("Yellow")).or_insert(50);
*v += 100;
println!("{}", scores.get(&String::from("Yellow")).unwrap())
```

`or_insert` 方法事实上会返回这个键的值的一个可变引用（`&mut V`）。
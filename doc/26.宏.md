Rust 的宏系统按定义的方式可以分为两大类 :

- 声明宏 (Declarative Macro)
- 过程宏 (Procedural Macro)

声明宏是指通过 macro_rules!声明定义的宏 ， 它是 Rust 中最常用的宏。过程宏分别为自定义 `#[derive]` 宏、类属性（Attribute）宏、类函数宏。

#### 声明宏

`macro_rules!` 来定义宏，声明宏允许我们编写一些类似 Rust `match` 表达式的代码，其接收一个表达式，与表达式的结果进行模式匹配，然后根据模式匹配执行相关代码。宏也将一个值和包含相关代码的模式进行比较，值是传递给宏的 Rust 源代码字面值，模式用于和传递给宏的源代码进行比较，同时每个模式的相关代码则用于替换传递给宏的代码。所有这一切都发生于编译时。

```rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```

`#[macro_export]` 注解说明宏应该是可用的。 如果没有该注解，这个宏不能被引入作用域。接着使用 `macro_rules!` 和宏名称开始宏定义，且所定义的宏并 *不带* 感叹号。

宏定义中有效模式语法模式语法是不同的，因为宏模式所匹配的是 Rust 代码结构而不是值。`($x:expr)`表示匹配一个表达式，然后存入x变量，`$(),*`表示重复匹配`$()`中的模式。以`vec![1, 2, 3];` 调用宏时，`$x` 模式与三个表达式 `1`、`2` 和 `3` 进行了三次匹配。

#### 过程宏

 过程宏(procedural macros)它们更像函数。过程宏接收 Rust 代码作为输入，在这些代码上进行操作，然后产生另一些代码作为输出，而非像声明式宏那样匹配对应模式然后以另一部分代码替换当前代码。过程宏包含一个函数，这也是其得名的原因。


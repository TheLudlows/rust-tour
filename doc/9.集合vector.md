#### vector

 `Vec` 是一个由标准库提供的类型，它可以存放任何类型。如果想要能够改变它的值，必须使用 `mut` 关键字使其可变。放入其中的所有值都是相同类型的。

```rust
fn main() {
    let mut v = Vec::new();
    //let v = vec![1, 2, 3];
    v.push(100);
}
```

类似于任何其他的 `struct`，vector 在其离开作用域时会被释放，所有其内容也会被丢弃，这意味着这里它包含的整数将被清理。

有两种方法引用 vector 中储存的值，索引语法或者 `get` 方法。

```rust
let v = vec![1, 2, 3, 4, 5];
let third: &i32 = &v[2];
println!("The third element is {}", third);

match v.get(2) {
  Some(third) => println!("The third element is {}", third),
  None => println!("There is no third element."),
}
```

使用 `&` 和 `[]` 返回一个引用；或者使用 `get` 方法以索引作为参数来返回一个 `Option<&T>`。Rust 有两个引用元素的方法的原因是程序可以选择如何处理当索引值在 vector 中没有对应值的情况。当 `get` 方法被传递了一个数组外的索引时，它不会 panic 而是返回 `None`。

一旦程序获取了一个有效的引用，借用检查器将会执行所有权和借用规则来确保 vector 内容的这个引用和任何其他引用保持有效。不能在相同作用域中同时存在可变和不可变引用的规则。当我们获取了 vector 的第一个元素的不可变引用并尝试在 vector 末尾增加一个元素的时候，会产生错误。

```rust
let mut v = vec![1, 2, 3, 4, 5];
let first = &v[0];
v.push(6);
println!("The first element is: {}", first);
```

在 vector 的结尾增加新元素时，在没有足够空间将所有所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况。

遍历

```rust
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
let v = vec![100, 32, 57];
for i in &v {
    println!("{}", i);
}
```

为了修改可变引用所指向的值，在使用 `+=` 运算符之前必须使用解引用运算符（`*`）获取 `i` 中的值。

我们提到 vector 只能储存相同类型的值。这是很不方便的；绝对会有需要储存一系列不同类型的值的用例。幸运的是，枚举的成员都被定义为相同的枚举类型，所以当需要在 vector 中储存不同类型值时，我们可以定义并使用一个枚举！

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```


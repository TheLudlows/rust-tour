





#### 语句与表达式

Rust 的语法可以分成两大类：语句 Statement 和表达式 Expression 。语句是指 要执行的一些操作和产生副作用的表达式。表达式主要用于计算求值。 

语句又分为两种： 声明语句 Declaration statement 和 表达式语句 Expression statement 。声明语句，用于声明各种语言项 (Item ），包括声明变量、静态变量、常量 结构体、 函数等，以及通过 extern use 关键字引入包和模块等。 表达式语句，特指以分号结尾的表达式。此类表达式求值结果将会被舍弃 并总是返 回单元类型（）

Rust 编译器在解析代码的时候，如果碰到分号，就会继续往后面执行；如果碰到语旬， 则执行语句；如果碰到表达式，则会对表达式求值，如果分号后面什么都没有，就会补上单元值()。

当遇到函数的时候，会将函数体的花括号识别为块表达式（Block Expression ）。块表达式是由一对花括号和一系列表达式组成的，它总是返回块中最后一个表达式的值。

#### 变量&绑定

使用关键词 let 声明变量，变量的数据类型是从被分配的值而推断出来的，名称:类型的形式定义。let创建的变量一般称为绑定，它表明了标识符和值之间建立一种关联关系。

#### 位置表达式和值表达式

Rust 的表达式一般可以分为位置表达式 Place Expression ）和 值表达式 Value Expression ）。在其他语言中， 一般叫作左值 (LValue ）和右值（RValue）。

位置表达式就是表示内存位置的表达式。分别有以下几类

- 本地变量

- 静态变量

- 解引用（*expr）

- 数组索引（ expr[expr] ) 

- 字段引用（ expr.field) 

- 位置表达式组合

通过位置表达式可以对某个数据单元的内存进行读写。主要是进 写操作，这也是位置表达式可以被赋值的原因。

除此之外的表达式就是值表达式。值表达式一般只引用了某个存储单元地址中的数据它相当于数据值，只能进行读操作。

#### 可变绑定和不可变绑定

使用 let 关键字声明的位置表达式默认不可变，为不可变绑定。从语义上来说， 默认声明的不可变绑定只能对相应的存储单元进行读取，而 let mut 声明的可变绑定 是可以对相应的存储单元进行写入的。

#### 常量
声明常量使用 const 关键字，不允许对常量使用 mut，它总是不能变。
常量可以在任何作用域中声明，包括全局作用域,在声明它的作用域之中，常量在整个程序生命周期中都有效。

#### 隐藏
我们可以定义一个与之前变量同名的新变量，而新变量会隐藏之前的变量。并且新变量和旧变量可以不同类型。

#### 类型
在 Rust 中，每一个值都属于某一个数据类型（data type），们将看到两类数据类型子集：标量（scalar）和复合（compound）。
标量（scalar）类型代表一个单独的值。Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型

复合类型（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。

元组是一个将多个其他类型的值组合进一个复合类型的主要方式。
与元组不同，数组中的每个元素的类型必须相同。Rust 中的数组与一些其他语言中的数组不同，因为 Rust 中的数组是固定长度的一旦声明，它们的长度不能增长或缩小。
数组中的值位于中括号内的逗号分隔的列表中。

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```
数组在栈（stack）而不是在堆（heap）上为数据分配空间，但是数组并不如 vector 类型灵活。vector 类型是标准库提供的一个 允许 增长和缩小长度的类似数组的集合类型。
Rust 语言为数组的声明和初始化提供了 3 中语法
```rust
let arr1:[u32;4] = [1,2,3,4];
// 类型和长度可以省略
let arr2 = ["a","b","c"];
// 默认值初始化
let arr3 = [2,5];
```
因为数组的长度在编译时就时已知的，因此我们可以使用 for ... in 语句来遍历数组。
```rust
for index in 0..4 {
    println!("index is: {} & value is : {}",index,arr1[index]);
}
for val in arr1.iter(){
  println!("value is :{}",val);
}
```
数组可以作为函数的参数。而传递方式有 传值传递 和 引用传递 两种方式。传值传递 就是传递数组的一个副本给函数做参数，函数对副本的任何修改都不会影响到原来的数组。
引用传递 就是传递数组在内存上的位置给函数做参数，因此函数对数组的任何修改都会影响到原来的数组。

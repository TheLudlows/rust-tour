

[toc]

#### 函数

main 函数，它是很多程序的入口点。你也见过 fn 关键字，它用来声明新函数。函数体由一系列的语句和一个可选的结尾表达式构成。

语句（Statements）是执行一些操作但不返回值的指令。表达式（Expressions）计算并产生一个值。使用 let 关键字创建变量并绑定一个值是一个语句。表达式会计算出一些值，如简单的数学运算、函数调用、作用域的大括号代码块，也可以是一个表达式。

函数可以向调用它的代码返回值。我们并不对返回值命名，但要在箭头（->）后声明它的类型。在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。使用 return 关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式。

#### 作用域和生命周期

Rust 语言的作用域是静态作用域，即词法作用域（ Lexical Scope），由一对花括号开辟作用于，其作用于在词法分析阶段就已经确定，不会改变。

使用let定义同名变量的做法叫变量遮蔽 Variable Shadow 。但是最终的变量 的值是由第二个变 量定义所决定。

```rust
fn main() {
    let v = "hello world";
    assert_eq!(v,"hello world");
    {
        let v = "hello rust";
        assert_eq!(v,"hello rust");

    }
}
```

在词法作用域内部使用花括号开辟新的词法作用域后，两个作用域是相互独立 。在不同的词法作用域内声明的变量绑定 ，拥有不同的生命周期 (LifeTime ）。尽管如此， 变量绑定的生命周期总是遵循这样的规律：从使用 let 声明创建变量绑走开始，到超出词法作用域的范围时结束

#### 函数指针

Rust中函数为一等公民。这意味着 ，函数自身就可以作为函数的参数和返回值使用。

```rust
fn main() {
    let a = 10;
    let b = 20;
    let r = doSome(sum,a,b);
    assert_eq!(r,30)
}

fn sum(a:usize,b:usize) -> usize{
    a+b
}
fn doSome(op: fn(usize,usize) -> usize,a:usize,b:usize)->usize {
    op(a,b)
}
```

#### 函数参数

函数参数可按值传递， 可以按引用传递。当参数按值传递时 会转移所有权或者执行复制（ Copy ）语义。当参数按引用传递时， 所有权不会发生 ，但是需要有生命周期参数。当符合生命周期参数省略规则时， 编译器可以通过自动推断补齐函数参数的生命周期参数，否则，需要显式地为参数标明生命周期参数。

函数参数也分为可变和不可变。 Rust 的函数参数默认不可变 当需要可变操作的时候， 需要使用 mut 关键字来修饰

```rust
fn main() {
    let v = vec![];
    let v = add(v);
    println!("{:?}",v)
}
fn add(mut v:Vec<i32>) -> Vec<i32> {
    v.push(20);
    v
}
```

add函数对其传入动态数组，所以需要传入可变的参数，同时v的所有权会被转移，参数相当于重新声明的另一个变量绑定，mut 关键字被放到参数变量前面作为可变修饰。所以 main 函数中声明的时候并没有使用 mut 关键字。

```rust
fn main() {
    let mut v = vec![];
    add(&mut v);
    println!("{:?}",v)
}

fn add(v:&mut Vec<i32>){
    v.push(20);
}
```

add函数参数本身已经是可变引用类型＆mut Vec<i32> ，所以此处的函 参数前面不需要再使用 mut 关键字。调用处则需要使用&mut 来声明入参的类型。


**方法** 与函数类似：它们使用 `fn` 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义（或者是枚举或 trait 对象的上下文，），并且它们第一个参数总是 `self`，它代表调用该方法的结构体实例。

#### 定义

下面定义了一个`Rectangle` 结构体上的 `area` 方法：

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

在 `area` 的签名中，使用 `&self`参数，因为该方法位于 `impl Rectangle` 上下文中所以 Rust 知道 `self` 的类型是 `Rectangle`，注意仍然需要在 `self` 前面加上 `&`。我们并不想获取所有权，只希望能够读取结构体中的数据，而不是写入。如果想要在方法中改变调用方法的实例，需要将第一个参数改为 `&mut self`。



每个结构体都允许拥有多个 `impl` 块

#### 关联函数

`impl` 块的另一个有用的功能是：允许在 `impl` 块中定义 **不** 以 `self` 作为参数的函数。这被称为 **关联函数**（*associated functions*），因为它们与结构体相关联。它们仍是函数而不是方法，因为它们并不作用于一个结构体的实例。你已经使用过 `String::from` 关联函数了。关联函数经常被用作返回一个结构体新实例的构造函数。使用结构体名和 `::` 语法来调用这个关联函数。

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
    fn can_hold(&self, other: &Rectangle) -> bool {
        other.height <= self.height && self.width >= other.width
    }
    fn from(width: u32, height: u32) -> Rectangle {
        Rectangle{
            width,
            height
        }
    }
}
```


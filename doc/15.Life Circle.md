Rust 中的每一个引用都有其 **生命周期**（*lifetime*），也就是引用保持有效的作用域。

####  避免垂悬引用

生命周期的主要目标是避免悬垂引用，它会导致程序引用了非预期引用的数据。

```rust
{
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}
```

外部作用域声明了一个没有初值的变量 `r`，而内部作用域声明了一个初值为 5 的变量`x`。在内部作用域中，我们尝试将 `r` 的值设置为一个 `x` 的引用。接着在内部作用域结束后，尝试打印出 `r` 的值。这段代码不能编译因为 `r` 引用的值在尝试使用之前就离开了作用域。

如果 Rust 允许这段代码工作，`r` 将会引用在 `x` 离开作用域时被释放的内存，这时尝试对 `r` 做任何操作都不能正常工作。那么 Rust 是如何决定这段代码是不被允许的呢？这得益于借用检查器。Rust 编译器有一个 **借用检查器**（*borrow checker*），它比较作用域来确保所有的借用都是有效的。

r和x的生命周期如下图所示

![](./img/lf.png)

这里将 `r` 的生命周期标记为 `'a` 并将 `x` 的生命周期标记为 `'b`。内部的 `'b` 块要比外部的生命周期 `'a` 小得多。在编译时，Rust 比较这两个生命周期的大小，并发现 `r` 拥有生命周期 `'a`引用了一个拥有生命周期 `'b` 的对象。程序被拒绝编译，因为生命周期 `'b` 比生命周期 `'a` 要小：被引用的对象比它的引用者存在的时间更短。

改为下面代码即可以通过编译

```rust
{
    let r;
    let x = 5;
    r = &x;
    println!("r: {}", r);
}
```

这里r和x的生命周期相同，r中的引用在x有效时总是也总是有效的。

#### 生命周期注解

先来看一段代码

```rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

这个函数获取两个字符串 slice 并返回一个字符串 slice，因为我们不希望 `longest` 函数获取参数的所有权。我们期望该函数接受 `String` 的 slice。但是这段代码不能通过编译。

当我们定义这个函数的时候，并不知道传递给函数的具体值，所以也不知道到底是 `if` 还是 `else` 会被执行。我们也不知道传入的引用的具体生命周期，所以也就不能像前面的示例那样通过观察作用域来确定返回的引用是否总是有效。借用检查器自身同样也无法确定，因为它不知道 `x` 和 `y` 的生命周期是如何与返回值的生命周期相关联的。

为了修复这个错误，我们将增生命周期注解来定义引用间的关系以便`借用检查器`可以进行分析。生命周期注解也称作泛型生命周期。

生命周期注解并不改变任何引用的生命周期的长短。与当函数签名中指定了泛型类型参数后就可以接受任何类型一样，当指定了泛型生命周期后函数也能接受任何生命周期的引用。生命周期注解描述了多个引用生命周期相互的关系，而不影响其生命周期。

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

函数定义指定入参和返回值所有的引用必须有相同的生命周期 `'a`，继续看我们的调用方式

```rust
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
}
```

在这个例子中，`string1` 直到外部作用域结束都是有效的，`string2` 则在内部作用域中是有效的，而 `result` 则引用了一些直到内部作用域结束都是有效的值。

看另外一种调用方式

```rust
fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}
```

这种方式编译不能通过，尽管result引用指向string1，但是编译器不这么认为，因为我们通过生命周期注解告诉编译器函数返回引用的生命周期应该与传入参数的生命周期中较短那个保持一致。因此，借用检查器不允许示例代码，因为它可能会存在无效的引用。
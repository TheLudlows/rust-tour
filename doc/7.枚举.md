 Rust的枚举中，不同的枚举值可以携带不同类型及数量的数据，枚举的成员位于其标识符的命名空间中，使用时通过两个冒号。

```rust
fn main() {
    #[derive(Debug)]
    enum enum_ {
        a,
        b(String)
    
    }
    println!("{:?}", enum_::a);
    println!("{:?}", enum_::b(String::from("b")));
}
```

`Option` 是标准库定义的另一个枚举。

```rust
enum Option<T> {
    Some(T),
    None,
}
```

Rust 有一个叫做 `match` 的强大的控制流运算符，它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码。模式可由字面值、变量、通配符和许多其他内容构成。

 `match` 关键字后跟一个表达式，这里它可以是任何类型的。接下来是 `match` 的分支。一个分支有两个部，`=>` 运算符将模式和将要运行的代码分开。当 `match` 表达式执行时，它将结果值按顺序与每一个分支的模式相比较。如果模式匹配了这个值，这个模式相关联的代码将被执行。如果模式并不匹配这个值，将继续执行下一个分支。每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个 `match` 表达式的返回值。

```rust
fn main() {
    #[derive(Debug)]
    enum enum_ {
        a,
        b(String),
        s { num: u32, name: String },
    }
    println!("{:?}", enum_::a);
    println!("{:?}", enum_::b(String::from("b")));

    let e = enum_::b(String::from("four"));

    let num: Option<u32> = Some(10);
    match num {
        Some(t) => println!("T is {}", t),
        None => println!("no")
    };
    match e {
        enum_::a => println!("a"),
        enum_::b(str) => println!("{}", str),
        enum_::s { num, name } => println!("s")
    }
}
```

匹配分支的另一个有用的功能是可以绑定匹配的模式的部分值。这也就是如何从枚举成员中提取值的。可以用_匹配所有的模式。

如果只关心一种模式，可以使用if let来实现

```rust
let n: Option<u32> = Some(1);
if let n = Some(1) {
  println!("1")
}
```

